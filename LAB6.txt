-- Zadanie 1

CREATE OR REPLACE FUNCTION get_job_title(p_job_id IN jobs.job_id%TYPE) 
RETURN VARCHAR2 IS
  v_job_title jobs.job_title%TYPE;
BEGIN
  SELECT job_title INTO v_job_title
  FROM jobs
  WHERE job_id = p_job_id;

  RETURN v_job_title;

EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RETURN 'Job not found';
END;
/

-- Zadanie 2

CREATE OR REPLACE FUNCTION get_annual_salary(p_employee_id IN employees.employee_id%TYPE)
RETURN NUMBER IS
  v_salary employees.salary%TYPE;
  v_commission employees.commission_pct%TYPE;
  v_annual_salary NUMBER;
BEGIN
  SELECT salary, commission_pct INTO v_salary, v_commission
  FROM employees
  WHERE employee_id = p_employee_id;

  IF v_commission IS NULL THEN
    v_commission := 0;
  END IF;

  v_annual_salary := v_salary * 12 + (v_salary * v_commission);

  RETURN v_annual_salary;

EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RETURN NULL;
END;
/

-- Zadanie 3

CREATE OR REPLACE FUNCTION get_area_code(p_phone IN VARCHAR2)
RETURN VARCHAR2 IS
  v_area_code VARCHAR2(10);
BEGIN
  v_area_code := REGEXP_SUBSTR(p_phone, '\(\d+\)');

  IF v_area_code IS NOT NULL THEN
    v_area_code := REPLACE(REPLACE(v_area_code, '(', ''), ')', '');
  END IF;

  RETURN v_area_code;
END;
/

-- Zadnaie 4

CREATE OR REPLACE FUNCTION capitalize_first_last(p_text IN VARCHAR2)
RETURN VARCHAR2 IS
  v_len NUMBER := LENGTH(p_text);
  v_result VARCHAR2(4000);
BEGIN
  IF v_len = 0 THEN
    RETURN NULL;
  ELSIF v_len = 1 THEN
    RETURN UPPER(p_text);
  ELSE
    v_result := UPPER(SUBSTR(p_text, 1, 1)) ||
                LOWER(SUBSTR(p_text, 2, v_len - 2)) ||
                UPPER(SUBSTR(p_text, v_len, 1));
    RETURN v_result;
  END IF;
END;
/

-- Zadanie 5

CREATE OR REPLACE FUNCTION pesel_to_date(p_pesel IN VARCHAR2)
RETURN DATE IS
  v_year NUMBER;
  v_month NUMBER;
  v_day NUMBER;
  v_date DATE;
BEGIN
  v_year := TO_NUMBER(SUBSTR(p_pesel, 1, 2));
  v_month := TO_NUMBER(SUBSTR(p_pesel, 3, 2));
  v_day := TO_NUMBER(SUBSTR(p_pesel, 5, 2));

  IF v_month > 80 THEN
    v_year := 1800 + v_year;
    v_month := v_month - 80;
  ELSIF v_month > 60 THEN
    v_year := 2200 + v_year;
    v_month := v_month - 60;
  ELSIF v_month > 40 THEN
    v_year := 2100 + v_year;
    v_month := v_month - 40;
  ELSIF v_month > 20 THEN
    v_year := 2000 + v_year;
    v_month := v_month - 20;
  ELSE
    v_year := 1900 + v_year;
  END IF;

  v_date := TO_DATE(v_year || '-' || LPAD(v_month, 2, '0') || '-' || LPAD(v_day, 2, '0'), 'YYYY-MM-DD');

  RETURN v_date;

EXCEPTION
  WHEN OTHERS THEN
    RETURN NULL;
END;
/

-- Zadanie 6

CREATE OR REPLACE FUNCTION get_counts_by_country(p_country_name IN countries.country_name%TYPE)
RETURN VARCHAR2 IS
  v_country_id countries.country_id%TYPE;
  v_emp_count NUMBER;
  v_dept_count NUMBER;
BEGIN
  SELECT country_id INTO v_country_id
  FROM countries
  WHERE country_name = p_country_name;

  SELECT COUNT(*) INTO v_emp_count
  FROM employees e
  JOIN departments d ON e.department_id = d.department_id
  JOIN locations l ON d.location_id = l.location_id
  WHERE l.country_id = v_country_id;

  SELECT COUNT(*) INTO v_dept_count
  FROM departments d
  JOIN locations l ON d.location_id = l.location_id
  WHERE l.country_id = v_country_id;

  RETURN 'Employees: ' || v_emp_count || ', Departments: ' || v_dept_count;

EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RETURN 'Country not found';
END;
/

-- Zadanie 2.1

CREATE TABLE archiwum_departamentow (
  id NUMBER PRIMARY KEY,
  nazwa VARCHAR2(100),
  data_zamkniecia DATE,
  ostatni_manager VARCHAR2(200)
);

CREATE OR REPLACE TRIGGER trg_archiwum_departamentow
AFTER DELETE ON departments
FOR EACH ROW
DECLARE
  v_manager_name VARCHAR2(200);
BEGIN
  SELECT e.first_name || ' ' || e.last_name
  INTO v_manager_name
  FROM employees e
  WHERE e.employee_id = :OLD.manager_id;

  EXCEPTION WHEN NO_DATA_FOUND THEN
    v_manager_name := NULL;

  INSERT INTO archiwum_departamentow(id, nazwa, data_zamkniecia, ostatni_manager)
  VALUES (:OLD.department_id, :OLD.department_name, SYSDATE, v_manager_name);
END;
/

-- Zadanie 2.2

CREATE TABLE zlodziej (
  id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  username VARCHAR2(50),
  czas_zmiany TIMESTAMP DEFAULT SYSTIMESTAMP
);

CREATE OR REPLACE TRIGGER trg_salary_check
BEFORE INSERT OR UPDATE ON employees
FOR EACH ROW
DECLARE
  v_username VARCHAR2(50);
BEGIN
  v_username := SYS_CONTEXT('USERENV', 'SESSION_USER');

  IF :NEW.salary < 2000 OR :NEW.salary > 26000 THEN
    INSERT INTO zlodziej(username) VALUES (v_username);

    RAISE_APPLICATION_ERROR(-20001, 'Salary outside allowed range (2000-26000)');
  END IF;
END;
/

-- Zadanie 2.3

CREATE SEQUENCE emp_seq START WITH 1000 INCREMENT BY 1;

CREATE OR REPLACE TRIGGER trg_emp_id_auto
BEFORE INSERT ON employees
FOR EACH ROW
BEGIN
  IF :NEW.employee_id IS NULL THEN
    :NEW.employee_id := emp_seq.NEXTVAL;
  END IF;
END;
/

-- Zadanie 2.4 - Jeśli JOD to literówka i powinno być JOB

CREATE TABLE job_grades (
  grade_level VARCHAR2(2) PRIMARY KEY,
  lowest_salary NUMBER(8,2),
  highest_salary NUMBER(8,2)
);

CREATE OR REPLACE TRIGGER trg_block_job_grades
BEFORE INSERT OR UPDATE OR DELETE ON job_grades
BEGIN
  RAISE_APPLICATION_ERROR(-20002, 'Operation not allowed on JOB_GRADES table');
END;
/

-- Zadanie 2.5

CREATE OR REPLACE TRIGGER trg_block_salary_change
BEFORE UPDATE OF min_salary, max_salary ON jobs
FOR EACH ROW
BEGIN
  :NEW.min_salary := :OLD.min_salary;
  :NEW.max_salary := :OLD.max_salary;
END;
/

-- Zadanie 3

CREATE OR REPLACE PACKAGE region_pkg IS
  PROCEDURE create_region(p_region_id NUMBER, p_region_name VARCHAR2);
  PROCEDURE update_region(p_region_id NUMBER, p_region_name VARCHAR2);
  PROCEDURE delete_region(p_region_id NUMBER);
  FUNCTION get_region(p_region_id NUMBER) RETURN VARCHAR2;
  FUNCTION get_regions_by_name(p_name VARCHAR2) RETURN SYS_REFCURSOR;
END region_pkg;
/

CREATE OR REPLACE PACKAGE BODY region_pkg IS

  PROCEDURE create_region(p_region_id NUMBER, p_region_name VARCHAR2) IS
  BEGIN
    INSERT INTO regions(region_id, region_name) VALUES (p_region_id, p_region_name);
  EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
      RAISE_APPLICATION_ERROR(-20020, 'Region already exists');
  END;

  PROCEDURE update_region(p_region_id NUMBER, p_region_name VARCHAR2) IS
  BEGIN
    UPDATE regions SET region_name = p_region_name WHERE region_id = p_region_id;
    IF SQL%ROWCOUNT = 0 THEN
      RAISE_APPLICATION_ERROR(-20021, 'Region not found');
    END IF;
  END;

  PROCEDURE delete_region(p_region_id NUMBER) IS
  BEGIN
    DELETE FROM regions WHERE region_id = p_region_id;
    IF SQL%ROWCOUNT = 0 THEN
      RAISE_APPLICATION_ERROR(-20022, 'Region not found');
    END IF;
  END;

  FUNCTION get_region(p_region_id NUMBER) RETURN VARCHAR2 IS
    v_name VARCHAR2(50);
  BEGIN
    SELECT region_name INTO v_name FROM regions WHERE region_id = p_region_id;
    RETURN v_name;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RETURN NULL;
  END;

  FUNCTION get_regions_by_name(p_name VARCHAR2) RETURN SYS_REFCURSOR IS
    v_cursor SYS_REFCURSOR;
  BEGIN
    OPEN v_cursor FOR
      SELECT * FROM regions WHERE region_name LIKE '%' || p_name || '%';
    RETURN v_cursor;
  END;

END region_pkg;
/
